#!/usr/bin/env bash
# GNU bash, version 4.2.45(2)-release (x86_64-unknown-linux-gnu)
#
# © Copyright 2014 Ryan Delaney. All rights reserved. This work is
# distributed WITHOUT ANY WARRANTY whatsoever; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# README file for terms and conditions on your use of this software.
#

# Functions {{{1
verbose() {
  if [[ "$verbose" = "1" ]]; then
    echo "$1" >&2
  fi
}

error() {
  echo "$1" >&2
}
# }}}

# Validation {{{0
# Check that the function does not exist
if type ch &> /dev/null; then
  error 'ERROR: function ch() is defined. Unset it with `unset ch`.'
  return 1
fi
# }}}

# Function {{{0
ch() {
# Usage {{{1
#
usage() {
cat <<EOD
ch
© Copyright 2014 Ryan Delaney. All rights reserved.
Web site: http://github.com/rpdelaney

ch provides enhanced directory changing behavior.

Usage: chdir [PATH]

Options
  -?, --help                  print this help and return
  -v, --verbose               increase verbosity
  -s, --strict                don't recursively search for a suitable path
  -u, --up=N                  move up N directories
EOD
return 1
}

# Parameters {{{1
#
while :
do
  case $1 in
    --help | -\?)
      usage
      return 0
      ;;
    -v | --verbose)
      # Each instance of -v adds 1 to verbosity
      local verbose=$((verbose+1))
      shift
      ;;
    -u | --up=) # move up n directories
      local moveup="$2"
      shift
      ;;
    --) # End of all options
      shift
      break
      ;;
    -*)
      echo "WARN: Unknown option (ignored): $1" >&2
      shift
      ;;
    *)  # no more options. Stop while loop
      break
      shift
      ;;
  esac
done
# }}}
# Validation {{{1
if [[ -z "$1" ]]; then
  error "ERROR: Argument not optional."
  error "Try ch -? for usage instructions."
  return 1
fi
# }}}
finddir() { # {{{1
  new_dir="$1"

  if [[ "$new_dir" == '-' ]]; then
    return 0
  fi

  while [[ -z "$norecurse" ]]; do
    if [[ "$new_dir" != "." ]] || [[ "$new_dir" == "/" ]]; then
      error "Hit the ceiling at $new_dir"
      break
    elif [[ -d "$new_dir" ]]; then
      break
    elif [[ -d ".$new_dir" ]]; then
      new_dir=".$new_dir"
      break
    else
      error "No suitable target found at $new_dir"
      error " Recursing up the directory tree..."
      new_dir="$(dirname "$new_dir")"
    fi
  done

if [[ -d "$new_dir" ]]; then
  return 0
else
  return 1
fi
} # 1}}}
moveupdir() { # {{{1
  for i in seq 1 "$moveup"; do
    cd .. || return 1
  done
  return 0
} # }}}

# If -u argument was passed, move up N directories.
if [[ -n "$moveup" ]] && moveupdir "$1" ; then
  return 0
fi

if finddir "$1" ; then
  if [[ "$new_dir" != '.' ]] && builtin cd "$new_dir" ; then
    timeout 1 ls --color=auto --format=across --group-directories-first || echo "$scriptPath: Timeout listing directory contents."
  fi
else
  error "FATAL: Directory not found."
fi

unset usage
unset finddir
unset moveupdir
}
# vim: ft=sh foldmethod=marker foldlevel=0
